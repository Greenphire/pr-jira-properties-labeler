#!/bin/bash
set -e
set -o pipefail

# This is populated by our secret from the Workflow file.
if [[ -z "$GITHUB_TOKEN" ]]; then
	echo "Set the GITHUB_TOKEN env variable."
	exit 1
fi

# This one is populated by GitHub for free :)
if [[ -z "$GITHUB_REPOSITORY" ]]; then
	echo "Set the GITHUB_REPOSITORY env variable."
	exit 1
fi

URI_GITHUB=https://api.github.com
API_VERSION=v3
API_HEADER="Accept: application/vnd.github.${API_VERSION}+json"
AUTH_HEADER="Authorization: token ${GITHUB_TOKEN}"

labels_on_open_pull_request=("needs feedback")

ref=$(jq --raw-output .pull_request.head.ref "$GITHUB_EVENT_PATH")
owner=$(jq --raw-output .pull_request.head.repo.owner.login "$GITHUB_EVENT_PATH")
repo=$(jq --raw-output .pull_request.head.repo.name "$GITHUB_EVENT_PATH")

create_labels() {
    curl -X POST \
    -H "${AUTH_HEADER}" \
    -H "${API_HEADER}" \
    -d '{"labels": '"${labels_to_add}"'}' \
    "${URI_GITHUB}/repos/${owner}/${repo}/labels"
}

add_labels_to_the_pr() {
    local all_raw_labels=$@
    local labels_array=$(echo $all_raw_labels | tr "," "\n")
    local labels_to_add_in_json_format=$(printf '%s\n' "${labels_array[@]}" | jq -R . | jq -s .)

    curl -X POST \
    -H "${AUTH_HEADER}" \
    -H "${API_HEADER}" \
    -d '{"labels": '"${labels_to_add_in_json_format}"'}' \
    "${URI_GITHUB}/repos/${owner}/${repo}/issues/${pr_number}/labels"
}

get_jira_priority_of() {
    local issue_code=$1
    curl -X GET \
    -H "Authorization: Basic ${JIRA_ENCODED_TOKEN}" \
    "${URI_JIRA}/rest/api/latest/issue/${issue_code}"| \
    jq --raw-output .fields.priority.name
}

get_jira_code_from_pr_title() {
    local pr_title=$@
    echo $pr_title | sed -E 's/([A-Z]{4}-[0-9]{4}).*/\1/'
}

set_default_env_variables_if_needed() {
    if [[ -z $REGEXP_FOR_JIRA_CODE_ON_PR_TITLE ]]; then
        REGEXP_FOR_JIRA_CODE_ON_PR_TITLE = '^([A-Z]{4}-[0-9]{4})'
    fi

    if [[ -z $LABELS_ON_PULL_REQUEST_OPENED ]]; then
        LABELS_ON_PULL_REQUEST_OPENED="needs feedback"
    fi
}

main() {
    set_default_env_variables_if_needed;

    # In every runtime environment for an Action you have the GITHUB_EVENT_PATH
    # populated. This file holds the JSON data for the event that was triggered.
    # From that we can get the status of the pull request and if it was merged.
    # In this case we only care if it was closed and it was merged.
	action=$(jq --raw-output .action "$GITHUB_EVENT_PATH")
	merged=$(jq --raw-output .pull_request.merged "$GITHUB_EVENT_PATH")
	pr_number=$(jq --raw-output .number "$GITHUB_EVENT_PATH")
	pr_title=$(jq --raw-output .pull_request.title "$GITHUB_EVENT_PATH")

	echo "DEBUG -> action: $action merged: $merged pr_number: $pr_number title: $pr_title"

#	if [[ "$merged" == "true" ]]; then
        # We only care about the closed event and if it was merged.
        # If so, delete the branch.
#		ref=$(jq --raw-output .pull_request.head.ref "$GITHUB_EVENT_PATH")
#		owner=$(jq --raw-output .pull_request.head.repo.owner.login "$GITHUB_EVENT_PATH")
#		repo=$(jq --raw-output .pull_request.head.repo.name "$GITHUB_EVENT_PATH")

#		if [[ "$ref" == "$default_branch" ]]; then
#			# Never delete the default branch.
#			echo "Will not delete default branch (${default_branch}) for ${owner}/${repo}, exiting."
#			exit 0
#		fi
#
#		echo "Deleting branch ref $ref for owner ${owner}/${repo}..."
#		curl -XDELETE -sSL \
#			-H "${AUTH_HEADER}" \
#			-H "${API_HEADER}" \
#			"${URI_GITHUB}/repos/${owner}/${repo}/git/refs/heads/${ref}"
#
#		echo "Branch delete success!"
#	fi

	if [[ "$action" == 'opened' ]]; then
	    echo "Retrieving the JIRA issue code from the PR title..."
	    local issue_code=$(get_jira_code_from_pr_title $pr_title)
	    echo "Retrieving the priority of the issue code $issue_code from JIRA..."
	    local priority=$(get_jira_priority_of $issue_code)
        echo "Appending the priority label $priority to the labels to add when PR is opened..."
	    LABELS_ON_PULL_REQUEST_OPENED+=",$priority"
        echo "Adding labels $LABELS_ON_PULL_REQUEST_OPENED to the PR..."
	    add_labels_to_the_pr $LABELS_ON_PULL_REQUEST_OPENED
	fi
}

main "$@"